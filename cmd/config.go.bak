package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"

	"github.com/takutakahashi/awesome-mcp-proxy/server"
)

// configCmd represents the config command
var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Configuration management commands",
	Long: `Configuration management commands for the MCP proxy.

Use subcommands to generate, validate, or inspect configuration files.`,
}

// generateCmd represents the config generate command
var generateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generate a sample configuration file",
	Long: `Generate a sample configuration file for gateway mode.

This creates a YAML configuration file with default settings and example backends
that can be customized for your specific deployment.`,
	Run: func(cmd *cobra.Command, args []string) {
		generateConfig()
	},
}

// validateCmd represents the config validate command  
var validateCmd = &cobra.Command{
	Use:   "validate [config-file]",
	Short: "Validate a configuration file",
	Long: `Validate a gateway configuration file for syntax and structure.

Checks that the YAML syntax is valid and that all required fields are present
with appropriate values.`,
	Args: cobra.MaximumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		configFile := "config.yaml"
		if len(args) > 0 {
			configFile = args[0]
		}
		validateConfig(configFile)
	},
}

func init() {
	rootCmd.AddCommand(configCmd)
	configCmd.AddCommand(generateCmd)
	configCmd.AddCommand(validateCmd)

	// Flags for generate command
	generateCmd.Flags().StringP("output", "o", "config.yaml", "Output file path")
	generateCmd.Flags().Bool("force", false, "Overwrite existing file")
}

func generateConfig() {
	outputFile, _ := generateCmd.Flags().GetString("output")
	force, _ := generateCmd.Flags().GetBool("force")

	// Check if file exists
	if _, err := os.Stat(outputFile); err == nil && !force {
		fmt.Printf("Error: File %s already exists. Use --force to overwrite.\n", outputFile)
		os.Exit(1)
	}

	// Create default configuration
	config := server.DefaultGatewayConfig()

	// Add some example backends
	config.Groups = []server.Group{
		{
			Name: "local",
			Backends: []server.Backend{
				{
					Name:      "local-mcp-server",
					Transport: "http",
					Endpoint:  "http://localhost:3000/mcp",
					Headers: map[string]string{
						"Authorization": "Bearer ${MCP_TOKEN}",
					},
				},
				{
					Name:      "stdio-tool",
					Transport: "stdio",
					Command:   "python",
					Args:      []string{"-m", "my_mcp_tool"},
					Env: map[string]string{
						"PYTHONPATH": "${PWD}/tools",
						"DEBUG":      "true",
					},
				},
			},
		},
		{
			Name: "remote",
			Backends: []server.Backend{
				{
					Name:      "remote-api",
					Transport: "http",
					Endpoint:  "https://api.example.com/mcp",
					Headers: map[string]string{
						"Authorization": "Bearer ${REMOTE_API_KEY}",
						"User-Agent":    "awesome-mcp-proxy/0.1.0",
					},
				},
			},
		},
	}

	// Marshal to YAML
	data, err := yaml.Marshal(config)
	if err != nil {
		fmt.Printf("Error: Failed to marshal config: %v\n", err)
		os.Exit(1)
	}

	// Write to file
	if err := os.WriteFile(outputFile, data, 0644); err != nil {
		fmt.Printf("Error: Failed to write config file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Configuration file generated: %s\n", outputFile)
	fmt.Println("\nNext steps:")
	fmt.Println("1. Review and customize the configuration file")
	fmt.Println("2. Set environment variables referenced in the config")
	fmt.Printf("3. Start the gateway: awesome-mcp-proxy gateway -c %s\n", outputFile)
}

func validateConfig(configFile string) {
	fmt.Printf("Validating configuration file: %s\n", configFile)

	// Load and validate the config
	config, err := server.LoadGatewayConfig(configFile)
	if err != nil {
		fmt.Printf("❌ Validation failed: %v\n", err)
		os.Exit(1)
	}

	// Basic validation checks
	errors := []string{}

	if config.Gateway.Host == "" {
		errors = append(errors, "gateway.host is required")
	}

	if config.Gateway.Port == 0 {
		errors = append(errors, "gateway.port must be greater than 0")
	}

	if len(config.Groups) == 0 {
		errors = append(errors, "at least one backend group is required")
	}

	backendCount := 0
	for i, group := range config.Groups {
		if group.Name == "" {
			errors = append(errors, fmt.Sprintf("groups[%d].name is required", i))
		}

		if len(group.Backends) == 0 {
			errors = append(errors, fmt.Sprintf("groups[%d] must have at least one backend", i))
		}

		for j, backend := range group.Backends {
			backendCount++
			if backend.Name == "" {
				errors = append(errors, fmt.Sprintf("groups[%d].backends[%d].name is required", i, j))
			}

			if backend.Transport == "" {
				errors = append(errors, fmt.Sprintf("groups[%d].backends[%d].transport is required", i, j))
			} else if backend.Transport != "http" && backend.Transport != "stdio" {
				errors = append(errors, fmt.Sprintf("groups[%d].backends[%d].transport must be 'http' or 'stdio'", i, j))
			}

			if backend.Transport == "http" && backend.Endpoint == "" {
				errors = append(errors, fmt.Sprintf("groups[%d].backends[%d].endpoint is required for HTTP transport", i, j))
			}

			if backend.Transport == "stdio" && backend.Command == "" {
				errors = append(errors, fmt.Sprintf("groups[%d].backends[%d].command is required for stdio transport", i, j))
			}
		}
	}

	if len(errors) > 0 {
		fmt.Println("❌ Validation failed:")
		for _, err := range errors {
			fmt.Printf("  - %s\n", err)
		}
		os.Exit(1)
	}

	fmt.Printf("✅ Configuration is valid\n")
	fmt.Printf("   - %d backend groups configured\n", len(config.Groups))
	fmt.Printf("   - %d total backends configured\n", backendCount)
	fmt.Printf("   - Gateway will listen on %s:%d%s\n", 
		config.Gateway.Host, config.Gateway.Port, config.Gateway.Endpoint)
}